'use strict';

var callBind = require('call-bind');
var callBound = require('call-bind/callBound');
var GetIntrinsic = require('get-intrinsic');
<<<<<<< HEAD

var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);
/** @type {undefined | ((receiver: ArrayBuffer) => number) | ((receiver: unknown) => never)} */
var $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);
var $toString = callBound('Object.prototype.toString');

// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method
var abSlice = !!$ArrayBuffer && !$byteLength && new $ArrayBuffer(0).slice;
var $abSlice = !!abSlice && callBind(abSlice);

/** @type {import('.')} */
=======
var isTypedArray = require('is-typed-array');

var $ArrayBuffer = GetIntrinsic('ArrayBuffer', true);
var $Float32Array = GetIntrinsic('Float32Array', true);
var $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);

// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method
var abSlice = $ArrayBuffer && !$byteLength && new $ArrayBuffer().slice;
var $abSlice = abSlice && callBind(abSlice);

>>>>>>> e6b1d803f4086f6fbb8d461652672f5ed5086063
module.exports = $byteLength || $abSlice
	? function isArrayBuffer(obj) {
		if (!obj || typeof obj !== 'object') {
			return false;
		}
		try {
			if ($byteLength) {
<<<<<<< HEAD
				// @ts-expect-error no idea why TS can't handle the overload
				$byteLength(obj);
			} else {
				// @ts-expect-error TS chooses not to type-narrow inside a closure
=======
				$byteLength(obj);
			} else {
>>>>>>> e6b1d803f4086f6fbb8d461652672f5ed5086063
				$abSlice(obj, 0);
			}
			return true;
		} catch (e) {
			return false;
		}
	}
<<<<<<< HEAD
	: $ArrayBuffer
		// in node 0.8, ArrayBuffers have no prototype or own methods, but also no Symbol.toStringTag
		? function isArrayBuffer(obj) {
			return $toString(obj) === '[object ArrayBuffer]';
=======
	: $Float32Array
		// in node 0.8, ArrayBuffers have no prototype or own methods
		? function IsArrayBuffer(obj) {
			try {
				return (new $Float32Array(obj)).buffer === obj && !isTypedArray(obj);
			} catch (e) {
				return typeof obj === 'object' && e.name === 'RangeError';
			}
>>>>>>> e6b1d803f4086f6fbb8d461652672f5ed5086063
		}
		: function isArrayBuffer(obj) { // eslint-disable-line no-unused-vars
			return false;
		};
