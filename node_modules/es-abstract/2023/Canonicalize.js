'use strict';

<<<<<<< HEAD
var $TypeError = require('es-errors/type');
=======
var GetIntrinsic = require('get-intrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
>>>>>>> e6b1d803f4086f6fbb8d461652672f5ed5086063

var callBound = require('call-bind/callBound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

<<<<<<< HEAD
var isRegExpRecord = require('../helpers/records/regexp-record');
var caseFolding = require('../helpers/caseFolding.json');
=======
var Type = require('./Type');

var assertRecord = require('../helpers/assertRecord');
var caseFolding = require('../helpers/caseFolding');
>>>>>>> e6b1d803f4086f6fbb8d461652672f5ed5086063

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(rer, ch) {
<<<<<<< HEAD
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (typeof ch !== 'string') {
=======
	assertRecord(Type, 'RegExp Record', 'rer', rer);
	if (Type(ch) !== 'String') {
>>>>>>> e6b1d803f4086f6fbb8d461652672f5ed5086063
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (rer['[[Unicode]]'] && rer['[[IgnoreCase]]']) { // step 1
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 1.b
	}

	if (!rer['[[IgnoreCase]]']) {
		return ch; // step 2
	}

	var u = $toUpperCase(ch); // step 5

	if (u.length !== 1) {
		return ch; // step 7
	}

	var cu = u; // step 8

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 9
	}

	return cu; // step 10
};
